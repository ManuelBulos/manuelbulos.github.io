---
layout: post
title: GraphQL in iOS
tags: [GraphQL, iOS]
cover-img: https://i.imgrpost.com/imgr/2020/05/20/graphql-cover.png
comments: true
---
# GraphQL in iOS

- We use the [Apollo](https://github.com/apollographql/apollo-ios) client to execute queries and mutations against a GraphQL server.

- It returns results as query-specific Swift types.

- Apollo auto generates these Input and Output objects inside a file called API.swift, do **NOT** modify this file.

## Automatic Code Generation

1. Download the **schema.json** file from your GraphQL endpoint and add it to your xcode project.

	We can download it by installing the apollo package
	```
	npm install -g apollo
	```
	and then running :
	```
	apollo schema:download --endpoint=https://<YOUR-GRAPHQL-ENDPOINT> schema.json
	```
2. Add a Build Phase to your xcode target, we can call it '_Generate Apollo GraphQL API_'

	[Get The Build Phase Script](https://www.apollographql.com/docs/ios/installation/#adding-a-code-generation-build-step) depending on how you installed Apollo (cocoapods, carthage or SPM)

	**Make sure to drag it up and put it BEFORE the "Compile Sources" phase.**
	![graphql-buildphase-1.png](https://i.imgrpost.com/imgr/2020/05/19/graphql-buildphase-1.png)
In this case I use [CocoaPods]([https://cocoapods.org/](https://cocoapods.org/)) as my dependency manager, and "/AutoGenerated" is the folder I created which contains my schema.json file.

	When the project is built it will create or update the **API.swift** file inside the same folder.

## Adding Queries and Mutations

Apollo creates our swift objects using the schema.json file, but also all the .graphql files it can find inside our project.

We can add our queries and mutations in two new empty files inside our target folder, something like **Queries.graphql** and **Mutations.graphql** I like to place them inside the same folder where my schema.json file is.

{: .box-note}

**Note:** If a query or mutation works on your [GraphQL Playground](https://www.apollographql.com/docs/apollo-server/testing/graphql-playground/) it will work on your xcode project, you can just copy paste them into your .graphql files.

Now everytime the project builds it will use all the queries and mutations defined on those files to create the swift objects on the API.swift file.

## Mutations.graphql file

This is how my Mutations.graphql file looks. It's a common authentication process with social logins.
```
mutation registerUser($email: String!, $password: String!) {
 registerUser(email: $email, password: $password) {
  ...LoginDetails
 }
}

mutation loginWithPassword($email: String!, $password: String!) {
 loginWithPassword(email: $email, password: $password) {
  ...LoginDetails
 }
}

mutation loginWithProvider($idToken: String!, $idProvider: String!) {
 loginWithProvider(idToken: $idToken, idProvider: $idProvider) {
  ...LoginDetails
 }
}

fragment LoginDetails on LoginResult {
 token
 refreshToken
 user {
  userId
  email
  firstName
  lastName
 }
}
```


# Making the requests: ApolloHelper.swift
I like to abstract my network requests into a new class

```swift
import Apollo

/// Network Layer
public class ApolloHelper {

  /// The GraphQL Endpoint
  let graphQLURL: URL

  ///  Apollo Client
  private(set) lazy var apollo: ApolloClient = {
    let httpNetworkTransport = HTTPNetworkTransport(url: graphQLURL)
    httpNetworkTransport.delegate = self
    return ApolloClient(networkTransport: httpNetworkTransport)
  }()

  /// Adds "Authorization" header to each authenticated request
  var authorizationToken: String = String()

  /// Sets the ApolloClient endpoint and configures cache
  init(graphQLURL: URL) {
    self.graphQLURL = graphQLURL
    self.initCache()
  }

  /// Uses key "id" of each fetched object for caching purposes
  private func initCache() {
    apollo.cacheKeyForObject = { $0["id"] }
  }
}
```


Inside ApolloHelper.swift we can call the RegisterUserMutation

```swift
// MARK: - RegisterUserMutation

    typealias RegisterUserResult = Result<GraphQLResult<RegisterUserMutation.Data>, Swift.Error>

    typealias RegisterUserCompletion = ((Result<RegisterUserMutation.Data.RegisterUser, Swift.Error>) -> Void)

    func registerUser(credentials: Credentials, completion: @escaping RegisterUserCompletion) {
        let registerMutation = RegisterUserMutation(email: credentials.email, password: credentials.password)

        apollo.perform(mutation: registerMutation) { [weak self] result in
            DispatchQueue.main.async {
                self?.handleRegisterUser(result: result, completion: completion)
            }
        }
    }

    private func handleRegisterUser(result: RegisterUserResult, completion: RegisterUserCompletion) {
        switch result {
        case .success(let graphQLResult):
            if let register = graphQLResult.data?.registerUser {
                completion(.success(register))
            } else if let errors = graphQLResult.errors {
                completion(.failure(Error.graphQLErrors(graphQLResult.errors)))
            } else {
                let json = "\(graphQLResult.data.jsonValue)"
                completion(.failure(Error.unkownError(json)))
            }
        case .failure(let error):
            completion(.failure(error))
        }
    }
```

## Error handling: ApolloHelper+Error.swift
I created an extension for handling error messages form the apollo client

```swift
import Apollo

// MARK: - ApolloHelper Error

extension ApolloHelper {
    enum Error: Swift.Error, LocalizedError {
        case unkownError(String)
        case graphQLErrors([GraphQLError]?)

        public var errorDescription: String? {
            switch self {
            case .unkownError(let response):
                return "Unknown Error, response: \(response)"

            case .graphQLErrors(let errors):
                return errors?.localizedDescription
            }
        }
    }
}

extension Array where Element == GraphQLError {
    /// Joins the localizedDescription of a collection of erros
    var localizedDescription: String {
        self
            .map { $0.localizedDescription }
            .joined(separator: "\n")
    }
}

```

## Authenticated Requests: ApolloHelper+HTTP.swift
We don't need it for this example, but we can add HTTP headers to any request like this:

```swift
extension ApolloHelper: HTTPNetworkTransportPreflightDelegate {
    public func networkTransport(_ networkTransport: HTTPNetworkTransport, shouldSend request: URLRequest) -> Bool {
        return true
    }

    public func networkTransport(_ networkTransport: HTTPNetworkTransport, willSend request: inout URLRequest) {
        request.addValue("Bearer \(authorizationToken)", forHTTPHeaderField: "Authorization")
    }
}

```


# Finally, using the ApolloHelper class
On success we can acess the LoginDetails fragment defined on Mutations.graphql

```swift
func signUpButtonTapped() {
        apolloHelper.registerUser(credentials: credentials) { (result) in
            switch result {
            case .success(let data):
                let loginDetails = data.fragments.loginDetails
                print(loginDetails.token)
                print(loginDetails.user.firstName)
            case .failure(let error):
                print(error.localizedDescription)
            }
        }
    }
```

**Note:** If something is not working as expected make sure:
- All queries and mutations written inside your .graphql files are working on your [GraphQL Playground](https://www.apollographql.com/docs/apollo-server/testing/graphql-playground/)
- You have an updated schema.json file
- If after doing all that it still doesnt work you can always watch [this great talk ](https://www.youtube.com/watch?v=4o59zEna9gQ&t=2094s) by [Nikolas Burk](https://twitter.com/nikolasburk?lang=en) or [send me a message](https://twitter.com/manuelbulos)

Thanks for reading ðŸ‘»
